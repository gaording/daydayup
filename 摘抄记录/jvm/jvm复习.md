## java自动内存管理机制：

java虚拟机规范将jvm内存分为：堆、栈、方法区、程序计数器

但各种虚拟机具体实现有所不同

hotspot jdk7以前将方法区以“永久代”的方式实现，字符串常量池、类静态变量、类型信息都在方法区中，jdk7将符号引用改到native heap中，字符串常量池和类静态变量改到java heap中。jdk8完全放弃了永久代，采用了元空间的方式来实现方法区，直接申请在本地内存中。


堆存放对象实例数据，栈存放基础变量和对象引用地址，方法区存放类型信息和运行时常量池（类中的静态常量、各种字面量和符号引用），直接内存是java通过native函数库直接分配的堆外内存，避免java堆和native堆来回复制数据。

栈和堆的对象引用可以分为直接引用和句柄引用，直接引用寻址更快，句柄引用可以在GC时对象移动位置的时候无须更改栈中的指针。

对象创建过程：检查类型数据是否存在并初始化—>根据类型数据确定对象大小并分配空间—>如果开启useTLAB则用线程私有内存分配，否则采用线程共有的堆内存分配—>通过cas重试机制避免并发占用内存问题，成功分配内存，初始化为零值—>设置偏向锁—>将对象引用地址压入栈中—>更改程序计数器，执行下条指令

对象在堆中的数据结构为：对象头（mark word（哈希码、分代年龄、锁标识）+类型指针）、实例数据、对齐填充。实例数据各种类型的变量会有存放先后顺序，子类和父类也有顺序排序，对齐填充无实际意义，只是hotspot内存操作单位为8字节，所以方便虚拟机操作而做的填充。

jdk6时候String.intern方法会把首次遇到的字符串实例复制到永久代的字符串常量池中存储，返回的也是永久代里面这个字符串实例的引用，而由StringBuilder创建的字符串对象实例在java堆上，所以必然不可能是同一个引用，结果将返回false。而JDK7的intern方法就不需要拷贝字符串的实例到永久代了，既然字符串常量池已经移到java堆中，那只需要在常量池中记录一下首次出现的实例引用即可，因此intern返回的引用和StringBuilder.toString创建的字符串实例就是同一个。

java堆和元空间（jdk7时候的永久代）都有参数可设置大小，而栈没有参数设置大小，是动态扩展的。因此栈空间=操作系统内存-堆内存-方法区内存，线程分配过多时，栈空间会过大，导致操作系统内存不足，程序出现oom错误。java对于线程的空间分配和各个虚拟机的具体实现有关，用户级或内核级还不清楚都如何做的，然后线程分配单独的栈和程序计数器，共享堆内存，那线程会涉及到直接内存吗？怎样涉及的？


对象死亡判定有引用计数法和对象可达性分析判定，java采用的是可达性判定。判定对象是否存在到达GC Roots的引用链。GC Roots的对象分为以下几种：虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等；方法区中类静态属性引用的对象，譬如java类的引用类型静态变量；方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用；本地方法栈中JNI（通常所说的native方法）引用的对象；java虚拟机内部的引用，如基本数据类型对应的class对象，一些常驻的异常对象（比如NullPointException、OutOfMemoryError）等，还有系统类加载器；所有被同步锁（synchronized关键字）持有的对象；反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。

java对象被判定死亡时，会被放入f-queue队列中，然后回收对象时还会先执行一遍finalize方法，这里可以将对象复活（将对象引用赋予给其它的GC roots），但是只能复活一次。这个方法还是为了兼容c/c++而设立的。一般不用，忘记它。

java引用：强引用（Strongly Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）。

垃圾回收是基于分代理论的，有些对象朝生夕死，存活时间短，对这些对象回收能保证大部分被回收，小部分存活。而有些对象存活了很长时间，它们大概率仍会继续存活，这些对象的回收效率就比较低。采用分代算法因材施教能保证整体较高的效率。java因分代回收也就出现了“Minor GC”、“Major GC”、“Full GC”这些说法。弱分代假说、强分代假说、跨代引用假说

为了方便GC回收，避免遍历查找GC Roots时的stop the world问题，就出现了OopMap的数据结构，可以在指令流的一些位置保存引用关系，为了避免每条更改引用关系的指令都生成oopMap，虚拟机采用了安全点的方式，仅在“特定位置”选定安全点。GC发生时各线程主动轮询一个中断标志，为true时，则挂起线程进行等待。轮询和安全点位置是重合的。如果用户线程处于sleep或block状态，对于GC遍历是无影响的，这个区域叫做安全区域，线程走出安全区域时会进行检查GC是否正在遍历，若正在遍历，则一直等待，直到遍历结束。

跨代引用时，新生代中加入了记忆集的数据结构，避免将整个老年代加进GC roots的扫描范围。记忆集记录了从非收集区域指向收集区域的指针集合的抽象数据结构。最简单可用非收集区域中所有含跨代引用的对象数组来实现这个数据结构，但空间占用和维护成本都较高，hotspot采用“卡表”的方式去实现记忆集，就是记录某一块内存是否存在跨代指针，然后再去遍历查找就是了（卡表会将内存也分为指定内存大小的“卡页”，通过卡页的dirty标志位是否为1判定是否存在跨代指针）

写屏障是指卡表元素维护时（何时变脏、谁来变脏）机器码层面的一种AOP技术，hotspot的很多虚拟机都用了写屏障，但在G1出现之前，都只用了写后屏障。这样在赋值操作之后，就可以进行更新卡表操作。但多个线程同时操作卡表所在的缓存行时就会出现“伪共享”问题，解决方案是在更新卡表标识时先检查卡表标记，未被标记过时才将其标志为脏。（这一大段不理解，先跳过）

解决了gc roots遍历的问题，还有个问题就是堆中的广大对象如何与gc roots关联起来，如何做可达性分析。堆越大，堆中的对象标记时就要花费更长的停顿时间。那就要考虑减少标记时间。对象图之所以要在一个能保障一致性的快照上遍历的原因是：如果遍历时引用还在不断变化，就类似于redis的scan指令，可能会出现已经死亡的对象又被可达性路径上的对象引用，也有可能判定被引用的对象已经无法连接到可达性路径上了。所以gc回收就会出现回收正在用的对象或者本该被回收的垃圾对象未被回收。垃圾对象未被回收影响不大，就是多了一些浮存垃圾，但正在用的对象被回收就意味着会出现严重问题。

wilson从理论上证明了“对象消失”问题需要两个条件同时满足：

* 赋值器插入了一条或多条从黑色对象到白色对象的新引用
* 赋值器删除了全部从灰色对象到白色对象的直接或间接引用

因此解决并发扫描时的对象消失问题，只需破坏这两个条件中的任意一个即可。由此产生两种解决方案：“增量更新”（cms用）和“原始快照”（g1用）

垃圾收集器：serial（新生代。单线程、简单、延时相对高，但类似客户端这些虚拟机内存少时，延迟只有几十几百毫秒，用户可接受）、parnew（新生代。serial的并行版本，能跟cms配合工作，jdk9之后基本就算成为cms的一部分）、cms（老年代。并发工作）、G1（全堆，jdk9之后推荐采用g1）、parallel scavenge（新生代。类似parnew，关注点在于提高吞吐量，而不在于降低延迟，适用于交互性不高、但计算量大的服务端）、serial old（老年代。）parold（老年代）

cms：追求低延迟的收集器。适用于互联网B/S用户交互多的场景。基于标记-清除算法。过程为：初始标记；并发标记；重新标记（此处用了增量更新）；标记清除；

jdk9之后，g1成为服务端默认的垃圾收集器，cms成为过时（deprecate）的。之后会被废弃。g1采用了mixed gc模式，面向堆内任何部分来组成回收集，G1开创了基于region的堆内存布局，每个region都可以根据需要扮演eden、survior或者老年代空间。region中还有一类特殊的humongous区域，专门用来存储大对象。G1认为只要大小超过了一个region容量一半的对象即为大对象。而对于超过了整个region容量的超级大对象，将会被存放在N个连续的humongous region中，G1的大多数行为把humongous region作为老年代的一部分看待。g1会维护一个region垃圾回收的优先级列表，然后根据用户设定允许的收集停顿时间，优先处理回收价值最大的那些region。g1回收过程为：初始标记；并发标记；最终标记；筛选回收；

还有zgc、shenandoah等垃圾收集器，跳过，暂不讨论。

## 虚拟机对象分配：

1.先分配到eden区，当eden区容量不够时，就会触发minor GC，存活对象进入survivor区。survivor区内存不足时就会用老年代进行担保，这些对象就会提前转移到老年代中去。

2.大对象会直接进入老年代。大对象的判定标准是大于-XX:PretenureSizeThreshold参数的对象。避免eden区及两个survivor区之间来回复制，产生大量的内存复制操作。

3.长期存活对象进入老年代。长期的判定标准是-XX:MaxTenuringThreshold，默认为15。

4.动态对象年龄判断。如果在survivor空间中相同年龄所有对象大小的总和大于survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。

5.空间分配担保。在发生minor GC之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立，那么这一次Minor GC确保是安全的。如果不成立，虚拟机会看-XX：HandlePromotionFailure参数的设置值是否允许担保失败，如果允许，则会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，则尝试一次minor GC，若不大于或参数设置值不允许担保失败则进行full GC。jdk6之后，这个参数值无效了，虚拟机minor GC时会检查老年代最大可用连续空间是否大于历次晋升对象的平均大小。

-Xms设置虚拟机堆最小内存 -Xmx设置虚拟机堆最大内存 -Xmn设置虚拟机新生代内存

-XX:Survivor-Ratio=8设置eden区与survivor的空间比例

## 虚拟机常用工具：

jps 虚拟机进程状况工具

-q 只输出lvmid（本地虚拟机id），省略主类名称

-m 输出虚拟机进程启动时传递给主类main()函数的参数

-l 输出主类的全名，如果进程执行的是jar包，则输出jar路径

-v 输出虚拟机进程启动时的JVM参数

jstat  虚拟机统计信息监视工具(gc、类加载、即使编译器编译过的方法等)

jinfo java配置信息工具（实时查看和调整虚拟机各项参数）

jmap java内存映像工具，用于生成堆转储快照

jhat 虚拟机堆转储快照分析工具，一般不用，生产环境下的堆快照不会在服务器上直接分析，会复制到其他机器上进行分析。而且就算在本机进行分析，jvisualvm也比jhat更强大。

jstack java堆栈跟踪工具，生成虚拟机当前时刻的线程快照（threaddump）。可以定位线程出现长时间停顿的常见原因，如线程间死锁、死循环、请求外部资源导致的长时间挂起等。

其它一些工具，跳过

## java字节码解读：

魔数和class文件的版本

常量池：字面量和符号引用，常量表

访问标志：类或接口、public或private之类的

类索引、父类索引与接口索引集合

字段表集合：访问标志、字段索引等等

方法表集合：类似字段表（方法重载时java代码要求参数不同，但字节码文件中只要返回值不同也是ok的，字节码中特征签名的范围更大一些）

属性表集合：code属性、exceptions属性（明确throws的异常）

异常表

linenumbertable属性：堆栈信息中的行号

localvariabletable及localVariableTypeTable属性：栈帧中局部变量表变量和java源码中定义的变量之间的关系

sourcefile及sourceDebugExtension属性：记录class文件名的

constant value属性

innerClasses属性：内部类和宿主类之间的关联

deprecated及synthetic属性：标志位

stackMapTable属性：在字节码验证阶段被新类型检查验证器（Type Checker）使用

signature属性：记录泛型签名信息

bootstrapMethods属性：用于保存invokedynamic指令引用的引导方法限定符

methodParameters属性：记录方法的各个形参名称和信息

模块化相关属性：module、modulePackages、moduleMainClass

运行时注解相关属性：runtimeVisibleAnnotations

## java字节码指令集：

操作码的长度为一个字节（0～255），所以指令集的操作码总数不能超过256条。操作数超过一个字节时，就需从多个字节中拼接重建出具体数据的结构，性能会损失一些，但可以省略大量的填充和间隔符号。不考虑异常情况的伪代码如下：

do{

自动计算PC寄存器的值加1；

根据PC寄存器指示的位置，从字节码流中取出操作码；

if（字节码存在操作数）从字节码流中取出操作数；

执行操作码所定义的操作；

}while（字节码流长度>0）；

字节码和数据类型：java虚拟机的指令集中，大多数指令都包含其操作所对应的数据类型。

加载和存储指令：Tload加载局部变量到操作栈，Tstore将一个数值从操作数栈存储到局部变量    表，Tpush、Tconst将一个常量加载到操作数栈。T和泛型中的作用一致，表示i、f这些字母，wide扩充局部变量表的访问索引的指令

运算指令：用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶，如Tadd、Tsub等等

类型转换指令：将两种不同的数值类型相互转换，一般用于实现用户代码中的显示类型转换操作

对象创建和访问指令：jvm对对象实例和数组的创建与操作使用了不同的字节码指令

操作数栈管理指令：用于直接操作操作数栈

控制转移指令：条件分支ifeq等

方法调用和返回指令：invokevirtual-调用对象的实例方法，根据对象的实际类型进行分派。invokeinterface-用于调用接口方法，运行时会搜索一个实现了这个接口方法的对象。invokespecial-调用一些需要特殊处理的实例方法，如实例初始化方法、私有方法和父类方法invokestatic-调用类静态方法。invokedynamic-用于在运行时动态解析出调用点限定符所用的方法。          方法返回指令根据返回值类型区分的，如ireturn（返回值为boolean、byte、char、short和int类型时使用）、lreturn、freturn等。

异常处理指令：显示抛出异常的操作（throw语句）由athrow指令实现，具体catch中的异常由异常表处理

同步指令：就是锁，用管程monitor实现

## 虚拟机类加载机制：

jvm把描述类的数据从class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的java类型。java语言的运行期动态加载和动态连接（即运行期间完成类型的加载、连接和初始化）的特点使得java天生可以动态扩展，例如编写一个面向接口的应用程序，可以等到运行时再指定其实际的实现类，用户可以通过java预置的或自定义类加载器，让某个本地的应用程序在运行时从网络或其他地方上加载一个二进制流作为其程序代码的一部分。这种动态组装应用的方式目前已广泛应用到java程序之中，从最基础的Applet、JSP到相对复杂的OSGi技术，都依赖着java语言运行期类加载才得以诞生。

### 类加载时机

加载Loading-》连接Linking（验证Verification-》准备Preparation-》解析Resolution）-》初始化Initialization-》使用Using-》卸载Unloading

加载阶段什么情况开始，《java虚拟机规范》并未进行强制约束。初始化阶段，《java虚拟机规范》规定有且只有六种情况必须立即对类进行“初始化”（加载、验证、准备自然需要在此之前）。

1. 遇到new、getstatic、putstatic或invokestatic这四条字节码指令时。典型场景有：使用new关键字实例化对象；读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段例外）；调用一个类型的静态方法的时候。
2. 使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型未经过初始化，则需要先触发其初始化
3. 初始化类时，发现父类还未进行初始化，则先初始化父类
4. 当虚拟机启动时，用户需要指定一个要执行的主类（包含main方法的那个类），虚拟机会先初始化这个主类
5. 当使用jdk7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。
6. 当一个接口中定义了JDK8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。
### 类加载过程

加载：虚拟机只需要做三件事，1.通过一个类的全限定名来获取定义此类的二进制字节流2.将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构3.在内存中生成一个代表这个类的java.lang.class对象，作为方法区这个类的各种数据的访问入口。实现并未严格规定，开发者可随意扩展，比如获取类的二进制流就可以从zip文件（jar、war）、网络中（web applet）、运行时动态生成（proxy）、其他文件生成（jsp）、数据库（SAP Netweaver中间件服务器）、加密文件获取等各种方法中获取。获取类的二进制流的加载过程是开发人员灵活度很高的一个过程，开发人员可自定义类加载器，重写findclass或loadclass方法，实现根据自己的想法赋予应用程序获取运行代码的动态性。数组类是jvm直接在内存中动态构造出来的，但数组类的元素类型最终还是靠类加载器完成加载的。加载阶段结束后，类型数据被安置在方法区中，当然数据存储格式《java虚拟机规范》未具体规定，由虚拟机自行实现。

验证：为啥要验证呢，因为class文件又不都是java文件转换过去的，它可以以任何可能的形式生成，比如代理动态生成类、甚至键盘直接输入0、1之类的，很多java语法不允许的事情在class字节码层面就能实现，所以出于安全考虑，jvm会对字节码文件进行验证。验证大致分为1.文件格式验证（各种变量用法有没得问题，固定位置的字节码是不是按照虚拟机规范实现的）2.元数据验证（语义解析，是否符合虚拟机规范，final类是不是被继承了之类的）3.字节码验证（语义是否合法，各种指令流有没有用对）4.符号引用（符号引用中的各种全限定名能否找到对应类，各种引用的方法、字段等是否存在，是否可被当前类访问）。验证阶段是一个重要但非必需的阶段，如果代码被反复执行并验证过，则可以使用-Xverify:none参数关闭大部分类验证措施，缩短虚拟机类加载时间。








