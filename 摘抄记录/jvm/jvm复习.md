java自动内存管理机制：

java虚拟机规范将jvm内存分为：堆、栈、方法区、程序计数器

但各种虚拟机具体实现有所不同

hotspot jdk7以前将方法区以“永久代”的方式实现，字符串常量池、类静态变量、类型信息都在方法区中，jdk7将符号引用改到native heap中，字符串常量池和类静态变量改到java heap中。jdk8完全放弃了永久代，采用了元空间的方式来实现方法区，直接申请在本地内存中。


堆存放对象实例数据，栈存放基础变量和对象引用地址，方法区存放类型信息和运行时常量池（类中的静态常量、各种字面量和符号引用），直接内存是java通过native函数库直接分配的堆外内存，避免java堆和native堆来回复制数据。

栈和堆的对象引用可以分为直接引用和句柄引用，直接引用寻址更快，句柄引用可以在GC时对象移动位置的时候无须更改栈中的指针。

对象创建过程：检查类型数据是否存在并初始化—>根据类型数据确定对象大小并分配空间—>如果开启useTLAB则用线程私有内存分配，否则采用线程共有的堆内存分配—>通过cas重试机制避免并发占用内存问题，成功分配内存，初始化为零值—>设置偏向锁—>将对象引用地址压入栈中—>更改程序计数器，执行下条指令

对象在堆中的数据结构为：对象头（mark word（哈希码、分代年龄、锁标识）+类型指针）、实例数据、对齐填充。实例数据各种类型的变量会有存放先后顺序，子类和父类也有顺序排序，对齐填充无实际意义，只是hotspot内存操作单位为8字节，所以方便虚拟机操作而做的填充。

jdk6时候String.intern方法会把首次遇到的字符串实例复制到永久代的字符串常量池中存储，返回的也是永久代里面这个字符串实例的引用，而由StringBuilder创建的字符串对象实例在java堆上，所以必然不可能是同一个引用，结果将返回false。而JDK7的intern方法就不需要拷贝字符串的实例到永久代了，既然字符串常量池已经移到java堆中，那只需要在常量池中记录一下首次出现的实例引用即可，因此intern返回的引用和StringBuilder.toString创建的字符串实例就是同一个。

java堆和元空间（jdk7时候的永久代）都有参数可设置大小，而栈没有参数设置大小，是动态扩展的。因此栈空间=操作系统内存-堆内存-方法区内存，线程分配过多时，栈空间会过大，导致操作系统内存不足，程序出现oom错误。java对于线程的空间分配和各个虚拟机的具体实现有关，用户级或内核级还不清楚都如何做的，然后线程分配单独的栈和程序计数器，共享堆内存，那线程会涉及到直接内存吗？怎样涉及的？


对象死亡判定有引用计数法和对象可达性分析判定，java采用的是可达性判定。判定对象是否存在到达GC Roots的引用链。GC Roots的对象分为以下几种：虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等；方法区中类静态属性引用的对象，譬如java类的引用类型静态变量；方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用；本地方法栈中JNI（通常所说的native方法）引用的对象；java虚拟机内部的引用，如基本数据类型对应的class对象，一些常驻的异常对象（比如NullPointException、OutOfMemoryError）等，还有系统类加载器；所有被同步锁（synchronized关键字）持有的对象；反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。

java对象被判定死亡时，会被放入f-queue队列中，然后回收对象时还会先执行一遍finalize方法，这里可以将对象复活（将对象引用赋予给其它的GC roots），但是只能复活一次。这个方法还是为了兼容c/c++而设立的。一般不用，忘记它。

java引用：强引用（Strongly Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）。

垃圾回收是基于分代理论的，有些对象朝生夕死，存活时间短，对这些对象回收能保证大部分被回收，小部分存活。而有些对象存活了很长时间，它们大概率仍会继续存活，这些对象的回收效率就比较低。采用分代算法因材施教能保证整体较高的效率。java因分代回收也就出现了“Minor GC”、“Major GC”、“Full GC”这些说法。弱分代假说、强分代假说、跨代引用假说

为了方便GC回收，避免遍历查找GC Roots时的stop the world问题，就出现了OopMap的数据结构，可以在指令流的一些位置保存引用关系，为了避免每条更改引用关系的指令都生成oopMap，虚拟机采用了安全点的方式，仅在“特定位置”选定安全点。GC发生时各线程主动轮询一个中断标志，为true时，则挂起线程进行等待。轮询和安全点位置是重合的。如果用户线程处于sleep或block状态，对于GC遍历是无影响的，这个区域叫做安全区域，线程走出安全区域时会进行检查GC是否正在遍历，若正在遍历，则一直等待，直到遍历结束。

跨代引用时，新生代中加入了记忆集的数据结构，避免将整个老年代加进GC roots的扫描范围。记忆集记录了从非收集区域指向收集区域的指针集合的抽象数据结构。最简单可用非收集区域中所有含跨代引用的对象数组来实现这个数据结构，但空间占用和维护成本都较高，hotspot采用“卡表”的方式去实现记忆集，就是记录某一块内存是否存在跨代指针，然后再去遍历查找就是了（卡表会将内存也分为指定内存大小的“卡页”，通过卡页的dirty标志位是否为1判定是否存在跨代指针）

写屏障是指卡表元素维护时（何时变脏、谁来变脏）机器码层面的一种AOP技术，hotspot的很多虚拟机都用了写屏障，但在G1出现之前，都只用了写后屏障。这样在赋值操作之后，就可以进行更新卡表操作。但多个线程同时操作卡表所在的缓存行时就会出现“伪共享”问题，解决方案是在更新卡表标识时先检查卡表标记，未被标记过时才将其标志为脏。（这一大段不理解，先跳过）

解决了gc roots遍历的问题，还有个问题就是堆中的广大对象如何与gc roots关联起来，如何做可达性分析。堆越大，堆中的对象标记时就要花费更长的停顿时间。那就要考虑减少标记时间。对象图之所以要在一个能保障一致性的快照上遍历的原因是：如果遍历时引用还在不断变化，就类似于redis的scan指令，可能会出现已经死亡的对象又被可达性路径上的对象引用，也有可能判定被引用的对象已经无法连接到可达性路径上了。所以gc回收就会出现回收正在用的对象或者本该被回收的垃圾对象未被回收。垃圾对象未被回收影响不大，就是多了一些浮存垃圾，但正在用的对象被回收就意味着会出现严重问题。

wilson从理论上证明了“对象消失”问题需要两个条件同时满足：

* 赋值器插入了一条或多条从黑色对象到白色对象的新引用
* 赋值器删除了全部从灰色对象到白色对象的直接或间接引用

因此解决并发扫描时的对象消失问题，只需破坏这两个条件中的任意一个即可。由此产生两种解决方案：“增量更新”（cms用）和“原始快照”（g1用）

垃圾收集器：serial（新生代。单线程、简单、延时相对高，但类似客户端这些虚拟机内存少时，延迟只有几十几百毫秒，用户可接受）、parnew（新生代。serial的并行版本，能跟cms配合工作，jdk9之后基本就算成为cms的一部分）、cms（老年代。并发工作）、G1（全堆，jdk9之后推荐采用g1）、parallel scavenge（新生代。类似parnew，关注点在于提高吞吐量，而不在于降低延迟，适用于交互性不高、但计算量大的服务端）、serial old（老年代。）parold（老年代）

cms：追求低延迟的收集器。适用于互联网B/S用户交互多的场景。基于标记-清除算法。过程为：初始标记；并发标记；重新标记（此处用了增量更新）；标记清除；

jdk9之后，g1成为服务端默认的垃圾收集器，cms成为过时（deprecate）的。之后会被废弃。g1采用了mixed gc模式，面向堆内任何部分来组成回收集，G1开创了基于region的堆内存布局，每个region都可以根据需要扮演eden、survior或者老年代空间。region中还有一类特殊的humongous区域，专门用来存储大对象。G1认为只要大小超过了一个region容量一半的对象即为大对象。而对于超过了整个region容量的超级大对象，将会被存放在N个连续的humongous region中，G1的大多数行为把humongous region作为老年代的一部分看待。g1会维护一个region垃圾回收的优先级列表，然后根据用户设定允许的收集停顿时间，优先处理回收价值最大的那些region。g1回收过程为：初始标记；并发标记；最终标记；筛选回收；









