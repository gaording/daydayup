# Redis Protocol specification

resp通信协议，redis定制，也能用于其它client-server软件工程。文本类型字符串传输，浪费网络传输流量，但是数据库瓶颈在于内部逻辑处理，而不在于网络传输。

TCP/IP通信协议：

三次握手

客户端发送syn（请求建立连接），seq（一般为1）

服务端发送ack（收到请求，ack=客户端seq+1），syn（同意建立新连接），seq

客户端发送ack（确认收到服务端同意的消息，ack=服务端seq+1），seq（服务端ack）

四次挥手

客户端发送fin（请求关闭连接），seq

服务端发送ack（收到请求，ack=客户端seq+1），seq

服务端发送fin（我处理好了，也请求关闭连接），ack（ack=客户端seq+1），seq

客户端发送ack（收到释放连接信号，ack=服务端seq+1），seq（seq=服务端ack）

linux分为用户态和内核态两种形式，用户态权限比内核态小，内核态的进程能随意调用cpu、各种外设以及分配磁盘内存等等，而为了保证内核空间的相对安全，并且减少内核调用的代码复杂度，内核空间和用户空间存在一个系统调用层（调用层之上还被包装了各种库函数以及shell命令行）。一部分内存仅为内核态使用，用户态不允许访问。用户态的进程可通过系统调用命令去切换到内核态执行（中断和外设请求时也会切换到内核态）。切换的时候执行栈状态、寄存器状态、程序计数器等都要保存然后切换，是比较耗时的。线程分为用户级线程和内核级线程两种，内核级线程是操作系统可感知的，可以利用多核cpu主动切换，一个进程的多个线程可以并发执行，但是是通过抢占cpu时间片的方式，因此无法控制先后顺序。从这个角度说，java线程像是内核线程。用户线程是在用户空间的，操作系统无法感知，cpu执行的时候其实就是以进程为单位执行的，用户程序再对进程中的多个线程进行调度，其实就没很好的利用到cpu，任意一个线程阻塞，整个进程也就会同步阻塞了。所以用户线程要么就要得到操作系统的支持，能映射到内核线程，保证用户线程阻塞时也能进行切换（比如java的tomcat处理web请求的线程池）。要么就采用非阻塞的api（如nginx的事件回调机制），采用非阻塞api之后也可以在用户态主动放弃控制权，把控制权交给别的线程（如C Runtime的long jump，或者js的async await机制）。还可以在用户态自己写一种线程的调度方式，运行时自行决定最佳的切换方式（如go的Runtime调度机制）。要是阻塞线程的不是IO而是无限for loop，那就只有1还能执行别的线程了，因为采用的是cpu的抢占机制，别的都会陷入死循环，没有机会执行线程切换，这种情况，扣程序员工资即可。用户线程适用于web代理、api网关以及IM这样的场景（不阻塞或者可以调用非阻塞的api）。java线程是内核线程的实现方式，但是是内核线程的一种高级接口（轻量级线程LWP）。jdk1.2之前用的是用户线程，之后就改为内核线程，但是跟具体的操作系统有关，windowns和linux是一对一（一个用户线程一个lwp）的实现方式。

![图片](https://uploader.shimo.im/f/eaQtIfpMqBnLms2S.png!thumbnail?fileGuid=KTHCTTdC8xrYGGjQ)

solaris可1对1也可多对多

![图片](https://uploader.shimo.im/f/5jsN1noBFdVLaldG.png!thumbnail?fileGuid=KTHCTTdC8xrYGGjQ)

线程调度分为协同式调度和抢占式调度方式，lua脚本的协调例程就是这类实现。java中采用的是抢占式调度。java的线程join方法是通过wait去实现的，join可以设置等待时间，但如果join的对象锁之后又被别的线程拿到了，那就会出现超时了。

redis的快在于IO多路复用技术的应用。这里又把同步、异步、阻塞、非阻塞的概念过了一遍，很多次了，一直没太理解。用户进程通过系统调用访问内核进程时，无论读写，都涉及到了直接I/O和缓冲I/O的应用。内核有内存缓冲区，用户进程也有内存缓冲区，这涉及到了数据两次拷贝的问题。缓冲IO是存在一个内核缓冲区（页缓存）的概念，用户进程（可能先经过用户缓冲区）通过内核获取数据时，内核进程会先从磁盘加载数据到内核缓冲区，再拷贝到用户缓冲区，给用户进程使用。这是linux的默认策略，大部分情况下可以凭借内核缓冲提高命中率，减少读盘次数，优化效率（写的时候应用程序也是写入到内核缓冲即被认为写入成功，但操作系统会定时刷新页缓存到磁盘中，并不会立刻写入到磁盘上）。但是存在一个从磁盘复制到内核缓冲区的开销，有些类似数据库服务器之类的，对于磁盘上的数据存储很熟悉，想自己管理缓存，就会用直接IO，跳过内核缓冲区，减少复制开销。

多路复用可以用select（文件描述符有上限，且是轮询的方式，描述符过多时效率会下降，已经不再用了）、poll、epoll（文件描述符无上限，采用事件回调机制，有read/write数据时会自动通知）。redis定时任务会记录在一个被称为“最小堆”的数据结构中，每个循环周期里，Redis都会对最小堆里已经到时间点的任务进行处理。（这里还不清楚具体的实现）。想到了redis的key过时策略，有定时、定期和惰性删除，定时不容易做到，如果成千上万个key同时过期，单线程是解决不了这个问题的。所以有定期策略，redis默认1s扫描10次，每次扫描20个key，如果超过1/4key过期，则删除key并重复扫描过程，重复时间不能超过25ms。惰性删除是程序访问指定key时再去判断key是否已过期，过期则删除。如果过期key过多，内存不够用了，则会涉及到淘汰策略。默认是不淘汰，写入失败（不会用这个），还有allkeys-lru,allkeys-random,volatile-lru,volatile-random、volatile-ttl等淘汰方法。redis4之后，可以采用后台线程异步删除操作了，比如unlink key，flushall async都可以异步删除，从库中的key删除依赖主库中的同步删除命令。redis用的是近似lru算法，随机取出5个数（对象头都有一个lru字段记录使用次数），删除最老的那个，可以从allkeys或者volatile中获取。redis作者后来还推出了lfu（按照频率排序）模式

redis持久化：AOF+RDB  fork+cow

AOF增量新增,时间很长时，aof文件会很大，可调用bgrewritteaof达到瘦身的目的。可以配置aof的fsync（将内核页缓存强制刷到磁盘上）周期。持久化一般在从节点进行，主节点主要是写入数据的。通过管道减少每次读写的网络开销，read和write只会在sokcet对应的读写缓冲区阻塞一次，所有的数据会一次性返回。

redis事务，之前演示过了，不是严格的事务，只能保证串形化，multi、exec、discard、watch，代码中可以用pipeline区实现.

redis pub/sub基本用不到，jedis用时涉及到jedispubsub，用它做消息队列不如用新出的stream，或者用专门的mq。redis小对象压缩，小型站点一个4gb的内存就够用了。redis.conf中可以配置集合小对象存储的阀值，比如hash-max-ziplist-entries这些

redis回收key之后，你通过任务管理器看到的内存可能没什么变化，因为操作系统回收内存是以页为单位的，只要这页还有一个key存在，那么就不会被回收，但是redis是可以用这页的空闲内存的。在大量key频繁过期的情况下，就可能出现内存碎片。可以在配置文件中开启内存碎片清理config set activedefrag true。也可以手动清理memory purge。

redis用的内存大概可以分成自身内存、对象内存和缓冲内存，info memory会看到redis自己数据用到的内存和向操作系统请求分配的内存（系统分配内存多时说明有较多内存碎片，系统分配内存少时说明redis用了磁盘的swap区）。主从增量同步是主节点将自己的修改指令先存在一个环形buffer数组中，如果数组内容满了，就会从头覆盖。所以网络状况差时，从节点就无法通过buffer中的指令流增量同步。就需要用快照同步（bgsave）。从节点加入后会先进行一次快照同步（全量同步），在进行增量同步。配置文件可以加replicaof host port指定跟随的主节点，下次重启的时候就会自动生效，sentinel貌似也会根据这个参数自动连接主节点。命令行输入的slaveof no one也会不生效（被sentinel的定时通信然后更改给替换掉了）。wait命令可以等待主从同步，让异步复制变为同步复制（生产环境怎么可能会用吗，redis那时候就不可用了，扣工资的）。redis主从同步时可以不生成磁盘文件，将内存中的指令流直接通过socket发送给从节点，节约磁盘空间，浪费带宽，也节约了IO消耗，适用于带宽很多而且很顺畅的情况（没有文件生成会不会在网络突然断掉的情况下丢失掉这部分指令流呢）。

