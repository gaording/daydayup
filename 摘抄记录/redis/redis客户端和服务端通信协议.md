# Redis Protocol specification

resp通信协议，redis定制，也能用于其它client-server软件工程。文本类型字符串传输，浪费网络传输流量，但是数据库瓶颈在于内部逻辑处理，而不在于网络传输。

TCP/IP通信协议：

三次握手

客户端发送syn（请求建立连接），seq（一般为1）

服务端发送ack（收到请求，ack=客户端seq+1），syn（同意建立新连接），seq

客户端发送ack（确认收到服务端同意的消息，ack=服务端seq+1），seq（服务端ack）

四次挥手

客户端发送fin（请求关闭连接），seq

服务端发送ack（收到请求，ack=客户端seq+1），seq

服务端发送fin（我处理好了，也请求关闭连接），ack（ack=客户端seq+1），seq

客户端发送ack（收到释放连接信号，ack=服务端seq+1），seq（seq=服务端ack）

linux分为用户态和内核态两种形式，用户态权限比内核态小，内核态的进程能随意调用cpu、各种外设以及分配磁盘内存等等，而为了保证内核空间的相对安全，并且减少内核调用的代码复杂度，内核空间和用户空间存在一个系统调用层（调用层之上还被包装了各种库函数以及shell命令行）。一部分内存仅为内核态使用，用户态不允许访问。用户态的进程可通过系统调用命令去切换到内核态执行（中断和外设请求时也会切换到内核态）。切换的时候执行栈状态、寄存器状态、程序计数器等都要保存然后切换，是比较耗时的。线程分为用户级线程和内核级线程两种，内核级线程是操作系统可感知的，可以利用多核cpu主动切换，一个进程的多个线程可以并发执行，但是是通过抢占cpu时间片的方式，因此无法控制先后顺序。从这个角度说，java线程像是内核线程。用户线程是在用户空间的，操作系统无法感知，cpu执行的时候其实就是以进程为单位执行的，用户程序再对进程中的多个线程进行调度，其实就没很好的利用到cpu，任意一个线程阻塞，整个进程也就会同步阻塞了。所以用户线程要么就要得到操作系统的支持，能映射到内核线程，保证用户线程阻塞时也能进行切换（比如java的tomcat处理web请求的线程池）。要么就采用非阻塞的api（如nginx的事件回调机制），采用非阻塞api之后也可以在用户态主动放弃控制权，把控制权交给别的线程（如C Runtime的long jump，或者js的async await机制）。还可以在用户态自己写一种线程的调度方式，运行时自行决定最佳的切换方式（如go的Runtime调度机制）。要是阻塞线程的不是IO而是无限for loop，那就只有1还能执行别的线程了，因为采用的是cpu的抢占机制，别的都会陷入死循环，没有机会执行线程切换，这种情况，扣程序员工资即可。用户线程适用于web代理、api网关以及IM这样的场景（不阻塞或者可以调用非阻塞的api）。java线程是内核线程的实现方式，但是是内核线程的一种高级接口（轻量级线程LWP）。jdk1.2之前用的是用户线程，之后就改为内核线程，但是跟具体的操作系统有关，windowns和linux是一对一（一个用户线程一个lwp）的实现方式。

![图片](https://uploader.shimo.im/f/eaQtIfpMqBnLms2S.png!thumbnail?fileGuid=KTHCTTdC8xrYGGjQ)

solaris可1对1也可多对多

![图片](https://uploader.shimo.im/f/5jsN1noBFdVLaldG.png!thumbnail?fileGuid=KTHCTTdC8xrYGGjQ)

线程调度分为协同式调度和抢占式调度方式，lua脚本的协调例程就是这类实现。java中采用的是抢占式调度。java的线程join方法是通过wait去实现的，join可以设置等待时间，但如果join的对象锁之后又被别的线程拿到了，那就会出现超时了。

redis的快在于IO多路复用技术的应用。这里又把同步、异步、阻塞、非阻塞的概念过了一遍，很多次了，一直没太理解。用户进程通过系统调用访问内核进程时，无论读写，都涉及到了直接I/O和缓冲I/O的应用。内核有内存缓冲区，用户进程也有内存缓冲区，这涉及到了数据两次拷贝的问题。缓冲IO是存在一个内核缓冲区（页缓存）的概念，用户进程（可能先经过用户缓冲区）通过内核获取数据时，内核进程会先从磁盘加载数据到内核缓冲区，再拷贝到用户缓冲区，给用户进程使用。这是linux的默认策略，大部分情况下可以凭借内核缓冲提高命中率，减少读盘次数，优化效率（写的时候应用程序也是写入到内核缓冲即被认为写入成功，但操作系统会定时刷新页缓存到磁盘中，并不会立刻写入到磁盘上）。但是存在一个从磁盘复制到内核缓冲区的开销，有些类似数据库服务器之类的，对于磁盘上的数据存储很熟悉，想自己管理缓存，就会用直接IO，跳过内核缓冲区，减少复制开销。

多路复用可以用select（文件描述符有上限，且是轮询的方式，描述符过多时效率会下降，已经不再用了）、poll、epoll（文件描述符无上限，采用事件回调机制，有read/write数据时会自动通知）。redis定时任务会记录在一个被称为“最小堆”的数据结构中，每个循环周期里，Redis都会对最小堆里已经到时间点的任务进行处理。（这里还不清楚具体的实现）。想到了redis的key过时策略，有定时、定期和惰性删除，定时不容易做到，如果成千上万个key同时过期，单线程是解决不了这个问题的。所以有定期策略，redis默认1s扫描10次，每次扫描20个key，如果超过1/4key过期，则删除key并重复扫描过程，重复时间不能超过25ms。惰性删除是程序访问指定key时再去判断key是否已过期，过期则删除。如果过期key过多，内存不够用了，则会涉及到淘汰策略。默认是不淘汰，写入失败（不会用这个），还有allkeys-lru,allkeys-random,volatile-lru,volatile-random、volatile-ttl等淘汰方法。redis4之后，可以采用后台线程异步删除操作了，比如unlink key，flushall async都可以异步删除，从库中的key删除依赖主库中的同步删除命令。redis用的是近似lru算法，随机取出5个数（对象头都有一个lru字段记录使用次数），删除最老的那个，可以从allkeys或者volatile中获取。redis作者后来还推出了lfu（按照频率排序）模式

redis持久化：AOF+RDB  fork+cow

AOF增量新增,时间很长时，aof文件会很大，可调用bgrewritteaof达到瘦身的目的。可以配置aof的fsync（将内核页缓存强制刷到磁盘上）周期。持久化一般在从节点进行，主节点主要是写入数据的。通过管道减少每次读写的网络开销，read和write只会在sokcet对应的读写缓冲区阻塞一次，所有的数据会一次性返回。

redis事务，之前演示过了，不是严格的事务，只能保证串形化，multi、exec、discard、watch，代码中可以用pipeline区实现

